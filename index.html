<!DOCTYPE HTML>
<html lang="en-US">
<head>
  <meta name="viewport" content="width=device-width">
  <meta charset="UTF-8">
  
  <title>Finger Magic</title>
  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
      font-family: helvetica,arial,sans-serif;
    }
    canvas {
      display: block;
      background: #ccc;
      height: 100%;
      width: 100%;
    }
  </style>
  <script src="./bower_components/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="./bower_components/fit-curve/lib/fit-curve.min.js"></script>

  <link rel="import" href="./bower_components/localstorage-load/localstorage-load.html">
  <script src="tf.js"> </script>
  
</head>
<body>
  <canvas></canvas>
  <select id="select" onchange="load()">
  </select>
  <textarea></textarea>
  <div>
    <input type="checkbox" id="addTraining" name="feature" value="horns" /> <label for="addTraining">Edit training data</label>
  </div>
  <localstorage-load name="data"></localstorage-load>
  <button id="Button" onclick="train()" > Train </button>
  <a href=model.zip >model.zip</a>
  <a href=tranning.zip >tranning.zip</a>
  <a href=both.zip >both.zip</a>
<script>

//import * as tf from '@tensorflow/tfjs';

let c = document.querySelector('canvas');
let csv = document.querySelector('textarea');
let addTraining = document.querySelector('input#addTraining');
let cx = c.getContext('2d');
let mousedown = false;

const theSpells = ["Accio","Aguamenti","Alohomora","Avis","Bombarda","Colovaria","Engorgio","Epoximise","Evanesco","Expelliarmus","Flipendo","Fumos","Gemino","Impedimenta","Incendio","Locomotor","Lumos","Lumos Maxima","Oppugno","Orchideous","Periculum","Reducio","Reparo","Serpensortia","Wingardium Leviosa","not a Spell"].sort()

var x = document.getElementById("select");
theSpells.map(t => {
    var option = document.createElement("option");
    option.text = t;
    x.add(option);
});

const numberOfspells = theSpells.length;

let oldX = null;
var oldY = null;
let resolution = 27;
let spell = [];
let spells = [];
let labelsCurves = {};
for (index = 0; index < theSpells.length; ++index) {
    if (localStorage.getItem("labels")) {
        labelsCurves[theSpells[index]] = JSON.parse(localStorage.getItem("labels"))[theSpells[index]] || [];
    } else {
        labelsCurves[theSpells[index]] = [];
    }
}

let loaded
async function loadModel () {
  try {
    loaded = await tf.loadModel('localstorage://spelling');
   //  model.initialWeights = loaded.weights;
  } catch(e) {
    console.log("not loaded")
  }
}
loadModel()

let spellsOnLine;

function getRandom(arr) {
    return arr[Math.floor(Math.random()*arr.length)]
}
if (!Array.prototype.flat) {
  Array.prototype.flat = function() {
    return this.reduce(function (flat, toFlatten) {
      return flat.concat(Array.isArray(toFlatten) ? toFlatten.flat() : toFlatten);
    }, []);
  }
}
async function train() {
  // findShape
  const longestSpell = 10
  const spellSize = 2 * 4 * longestSpell;
  document.getElementById("Button").disabled = true;
  function getRandomSpell() {
    var label = getRandom(Object.keys(labelsCurves))
    var aSpell = getRandom(labelsCurves[label]).map(curve => curve.map(xy => xy.map(val => {
      return val
    })))

    let arrayOfZero = []
    for (let i = 0; i < numberOfspells; i++) {
        if (Object.keys(labelsCurves).indexOf(label) === i) {
            arrayOfZero.push(1)
        } else {
            arrayOfZero.push(0)
        } 
    }
        
    return [ arrayOfZero, aSpell.flat(3)]
  }
  
  function getBatch(batchSize) {
    let batchSpellsArray = []
    let batchLabelsArray = []

    for (let i = 0; i < batchSize; i++) {
      var spell = getRandomSpell();
      batchSpellsArray.push(spell[1]);
      var pad = Array.apply(null, Array(spellSize - spell[1].length)).map(Number.prototype.valueOf, 0)
      batchSpellsArray.push(pad);
      batchLabelsArray.push(spell[0]);
    }

    const xs     = tf.tensor2d(batchSpellsArray.flat(2), [batchSize, spellSize] ); //,      'bool');
    const labels = tf.tensor2d(batchLabelsArray, [batchSize, numberOfspells] );    //,      'bool');

    return {xs, labels};
  }

  const model = tf.sequential(); // TODO load

  const BATCH_SIZE = 80;
  const TRAIN_BATCHES = 40000;
  const LEARNING_RATE = 0.00001;
  const optimizer = tf.train.adam(LEARNING_RATE);
  if (model.add) {
    model.add(tf.layers.dense({units: 80,inputShape: [2 * 4 * longestSpell], kernelInitializer: 'varianceScaling', activation: 'elu'}));
    model.add(tf.layers.dense({units: 80, kernelInitializer: 'varianceScaling', activation: 'relu'}));
    model.add(tf.layers.dense({units: 80, kernelInitializer: 'varianceScaling', activation: 'relu'}));
    model.add(tf.layers.dense({units: numberOfspells, kernelInitializer: 'varianceScaling', activation: 'softmax'}));
    model.compile({
      optimizer: optimizer,
      loss: 'categoricalCrossentropy',
      metrics: ['accuracy'],
    });
  }

  // Every few batches, test accuracy over many examples. Ideally, we'd compute
  // accuracy over the whole test set, but for performance we'll use a subset.
  const TEST_BATCH_SIZE = 1;
  const TEST_ITERATION_FREQUENCY = 5;
  const SAVE_ITERATION_FREQUENCY = 2000;
  for (let i = 0; i < TRAIN_BATCHES; i++) {
    const batch = getBatch(BATCH_SIZE);

    await tf.nextFrame();
    let testBatch;
    let validationData;
    // Every few batches test the accuracy of the mode.
    if (i % TEST_ITERATION_FREQUENCY === 0) {
      testBatch = getBatch(TEST_BATCH_SIZE);
      validationData = [
        testBatch.xs, testBatch.labels
      ];
    }

    // The entire dataset doesn't fit into memory so we call fit repeatedly
    // with batches.
    const history = await model.fit( batch.xs, batch.labels, {batchSize: BATCH_SIZE, validationData, epochs: 1});

    await tf.nextFrame();
    batch.xs.dispose();
    batch.labels.dispose();
    if (testBatch != null) {
      console.log("% Done/Change/Accuracy " + Math.round(i/TRAIN_BATCHES*1000)/10, Math.round(history.history.loss[0] * 100)/100, Math.round( history.history.acc[0] * 1000)/10);
      testBatch.xs.dispose();
      testBatch.labels.dispose();
    }
    if (i % SAVE_ITERATION_FREQUENCY === 0 && Math.round( history.history.acc[0] * 10000) > 9999 ) {
       model.save('localstorage://spelling').then(v => {
         console.log("saved");
         loadModel();
       })
    }
    await tf.nextFrame();
  }
  model.save('localstorage://spelling').then(v => {
    console.log("saved", v);
    loadModel();
    document.getElementById("Button").disabled = false;
  });
}
function setupCanvas() {
  const e = document.getElementById("select");
  spells = labelsCurves[e.options[e.selectedIndex].text] || [];
  c.height = window.innerHeight - 30;
  c.width = window.innerWidth;
  cx.lineWidth = 10;
  cx.lineCap = 'round';
  cx.strokeStyle = 'rgb(0, 0, 50)';
  oldX = null;
  oldY = null;
  spells.map((s, idx) => {
    oldX = null;
    oldY = null;
    spellsOnLine = Math.floor(c.width / 30) - 1;
    const addY = (Math.floor(idx / spellsOnLine) * 30) + 10;
    const addX = 15 + ((idx % spellsOnLine) * 30);
    oldX = null;
    oldY = null;

    s.map((p, i, spell) => {
      cx.beginPath();
      cx.moveTo(p[0][0] + addX, p[0][1] + addY);
      cx.bezierCurveTo(p[1][0] + addX, p[1][1] + addY,p[2][0] + addX, p[2][1] + addY, p[3][0] + addX, p[3][1] + addY);
      cx.strokeStyle = 'rgb(128, 128, 128)';
      cx.lineWidth = 3;
      cx.stroke();
      cx.strokeStyle = 'rgb(0, 0, 0)';
      cx.lineWidth = 1;
      cx.stroke();
      cx.closePath();
      if (!i) {
        cx.beginPath();
        cx.moveTo(p[0][0] + addX, p[0][1] + addY);
        cx.lineTo(p[0][0] + addX, p[0][1] + addY);
        cx.strokeStyle = 'rgb(0,0,0)';
        cx.lineWidth = 5;
        cx.stroke();
        cx.strokeStyle = 'rgb(175, 255, 175)';
        cx.lineWidth = 4;
        cx.stroke();
        cx.closePath();
      }
      if (i + 1 == spell.length) {
        cx.beginPath();
        cx.moveTo(p[3][0] + addX, p[3][1] + addY);
        cx.lineTo(p[3][0] + addX, p[3][1] + addY);
        cx.strokeStyle = 'rgb(0,0,0)';
        cx.lineWidth = 5;
        cx.stroke();
        cx.strokeStyle = 'rgb(255, 175, 175)';
        cx.lineWidth = 4;
        cx.stroke();
        cx.closePath();
      } 
      
    })
    cx.strokeStyle = 'rgb(0, 0, 50)';
    cx.lineWidth = 10;
  })
}
function onmousedown(ev) {
  mousedown = true;
  ev.preventDefault();
}
function onmouseup(ev) {
  mousedown = false;
  ev.preventDefault();
  if (spell.length > 15) {
    predict(normSpell(spell)).then(p => {
        csv.value = p
    });
    save(normSpell(spell));
  } else if (addTraining.checked === true) {
    if (ev.changedTouches) {
      index = (Math.floor((ev.changedTouches["0"].clientY - 10) / 30) * spellsOnLine) + Math.floor((ev.changedTouches["0"].clientX - 15) / 30)
    } else {
      index = (Math.floor((ev.clientY - 10) / 30) * spellsOnLine) + Math.floor((ev.clientX - 15) / 30)
    }
    spells.splice(index, 1)
    oldX = null
    oldY = null
    spell = [];
    const e = document.getElementById("select");
    labelsCurves[e.options[e.selectedIndex].text] = spells;
    localStorage.setItem("labels", JSON.stringify(labelsCurves))
  }
  // reset
  setupCanvas();
}
var uniqueArray = function(arrArg) {
  return arrArg.filter(function(elem, pos,arr) {
    return arr.map(v => JSON.stringify(v)).indexOf(JSON.stringify(elem)) == pos;
  });
};
function predict(spellToRecognise) {
  let spellSize = 80
  let flatSp = spellToRecognise.flat(3)
  var pad = Array.apply(null, Array(spellSize - flatSp.length)).map(Number.prototype.valueOf, 0);
  return loaded.predict(tf.tensor2d(flatSp.concat(pad), [1,spellSize])).data().then(p => {
    let max = Math.max(... p)
    if (max > .8) {
      return Math.round(max * 100)/100 + ':' +  Object.keys(labelsCurves)[p.indexOf(max)]
    } else {
      return "??? - ???"
    }
  })
}
function save(spellToSave) {
  oldX = null
  oldY = null
  if (addTraining.checked === true) {
    spells.push(spellToSave)
    const e = document.getElementById("select");
    labelsCurves[e.options[e.selectedIndex].text] = uniqueArray(spells);
    localStorage.setItem("labels", JSON.stringify(labelsCurves))
    setupCanvas();
  }
  spell = []
}
function load() {
  const e = document.getElementById("select");
  spells = labelsCurves[e.options[e.selectedIndex].text] || [];
  setupCanvas()
}
function onmousemove(ev) {
  var x 
  var y  
  if (ev.changedTouches) { 
    x = ev.changedTouches["0"].clientX;
    y = ev.changedTouches["0"].clientY;  
    mousedown = true;
  } else {
    x = ev.clientX;
    y = ev.clientY;  
  }
  if (mousedown) {
    paint(x, y);
    addToArray(x, y);
  } 
}
function addToArray(x, y) {
    if (x > 0 && y > 0) {
        spell.push([x, y])
    }
}
function distance(pa, pb) {
  var a = pa[0] - pb[0];
  var b = pa[1] - pb[1];
  if (a || b) {
    return Math.sqrt(a*a + b*b);
  }
  return 0
}
function isInALine(a, b, c) {
   if (a && b && c) {
       return (distance(a, b) + distance(b, c)) === distance(a, c)
   }
   return false
}
function toCurve(s) {
    // max curves
    var size = 10 
    var op0 = fitCurve(s, 6);
    var op1 = fitCurve(s, 5);
    var op2 = fitCurve(s, 4);
    var op3 = fitCurve(s, 3);
    var op4 = fitCurve(s, 2);
    var op5 = fitCurve(s, 1);
    let picked
    if (op5.length <= size) {
      picked = op5;
    } else if (op4.length <= size) {
      picked = op4;
    } else if (op3.length <= size) {
      picked = op3;
    } else if (op2.length <= size) {
      picked = op2;
    } else if (op1.length <= size) {
      picked = op1;
    } else {
      picked = op0.slice(0, size);
    }

    return picked.map(v => v.map(va => va.map(val => {
        return Math.round(val)
    })))
}
function normCurve(Curve) {

  const minX = Curve.reduce((a, v) => {
    return Math.min(v[0][0],v[1][0],v[2][0],v[3][0],a)
  }, 2000)
  const minY = Curve.reduce((a, v) => {
    return Math.min(v[0][1],v[1][1],v[2][1],v[3][1],a)
  }, 2000)
  const maxX = Curve.reduce((a, v) => {
    return Math.max(v[0][0],v[1][0],v[2][0],v[3][0],a)
  }, 0)
  const maxY = Curve.reduce((a, v) => {
    return Math.max(v[0][1],v[1][1],v[2][1],v[3][1],a)
  }, 0)

  const factor = resolution / distance([maxX, maxY],  [minX, minY])
  return Curve.map(va => {
    return va.map(val => [Math.floor((val[0] - minX) * factor), Math.floor((val[1] - minY) * factor)] )
  })
}
function normSpell(theSpell) {
   
  const minX = theSpell.reduce((a, v) => {
    return Math.min(v[0],a)
  }, 2000)
  const minY = theSpell.reduce((a, v) => {
    return Math.min(v[1],a)
  }, 2000)
  const maxX = theSpell.reduce((a, v) => {
    return Math.max(v[0],a)
  }, 0)
  const maxY = theSpell.reduce((a, v) => {
    return Math.max(v[1],a)
  }, 0)

  const factor = resolution / distance([maxX, maxY],  [minX, minY])
  
  return normCurve(toCurve(spell.map(va => {
    return [Math.floor((va[0] - minX) * factor), Math.floor((va[1] - minY) * factor)]
  }).reduce((a,val,i,arr) => {
    // A-B---C drop B
    //
    // A-----B include B
    //      /
    //     C
    if (i === 0 || i + 1 === arr.length || !isInALine(a.slice(-1), val, arr[i+1])) { 
      a.push(val)
    }
    return a
  }, [])));
}
function paint(x, y) {
  cx.beginPath();
  if (oldX > 0 && oldY > 0) {
    cx.moveTo(oldX, oldY);
  }
  cx.lineTo(x, y);
  cx.stroke();
  cx.closePath();
  oldX = x;
  oldY = y;
}

c.addEventListener('mousedown', onmousedown, false);
c.addEventListener('mouseup', onmouseup, false);
c.addEventListener('mousemove', onmousemove, false);
c.addEventListener("touchstart", onmousedown, false);
c.addEventListener("touchend", onmouseup, false);
c.addEventListener("touchcancel", onmouseup, false);
c.addEventListener("touchmove", onmousemove, false);

setupCanvas();
</script>
</body>
</html>
